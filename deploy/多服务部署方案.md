# Go Workspace 和多服务部署方案

## 一、Go Workspace (go.work) 说明

### 1.1 什么是 go.work？

`go.work` 是 Go 1.18+ 引入的 **Workspace 模式**，用于管理多个 Go 模块的联合开发。

**主要作用：**
- 允许在本地同时开发多个相关模块
- 支持本地模块之间的相互引用（无需发布到仓库）
- 统一管理多个模块的依赖版本
- 提高开发效率，避免频繁的 `go mod tidy` 和版本发布

### 1.2 go.work 文件格式

```go
go 1.24

use (
    ./services/apps/basic-search
    ./services/apps/service-a
    ./services/apps/service-b
)

replace (
    // 可以在这里统一替换依赖
)
```

### 1.3 使用场景

**适合使用 go.work：**
- ✅ 多个服务共享公共代码库
- ✅ 本地开发时需要在服务间相互引用
- ✅ 需要统一管理多个服务的依赖版本
- ✅ 微服务架构下的联合开发

**不适合使用 go.work：**
- ❌ 服务之间完全独立，无代码共享
- ❌ 每个服务单独发布和部署
- ❌ CI/CD 流程中（应该使用 go.mod）

---

## 二、多服务部署方案

### 方案一：独立 Docker 镜像（推荐用于生产环境）

**特点：**
- 每个服务独立构建和部署
- 服务之间完全解耦
- 可以独立扩展和更新
- 适合 Kubernetes 等容器编排

**目录结构：**
```
services/apps/
├── basic-search/
│   ├── docker/
│   │   └── Dockerfile
│   ├── go.mod
│   └── ...
├── service-a/
│   ├── docker/
│   │   └── Dockerfile
│   ├── go.mod
│   └── ...
└── service-b/
    ├── docker/
    │   └── Dockerfile
    ├── go.mod
    └── ...
```

**部署方式：**
```bash
# 每个服务独立构建
cd services/apps/basic-search
docker build -f docker/Dockerfile -t basic-search:latest .

cd services/apps/service-a
docker build -f docker/Dockerfile -t service-a:latest .
```

**优点：**
- ✅ 服务独立，互不影响
- ✅ 可以独立扩展
- ✅ 适合微服务架构
- ✅ CI/CD 流程清晰

**缺点：**
- ❌ 需要为每个服务维护 Dockerfile
- ❌ 构建时间相对较长（多个镜像）

---

### 方案二：多阶段构建 + 统一 Dockerfile

**特点：**
- 使用一个 Dockerfile 构建多个服务
- 共享构建环境，减少重复
- 适合服务数量较少的情况

**目录结构：**
```
deploy/
└── docker/
    └── Dockerfile.multi-service
```

**Dockerfile 示例：**
```dockerfile
FROM golang:1.24.11 AS builder

WORKDIR /build

# 复制所有服务的 go.mod
COPY services/apps/*/go.mod services/apps/*/go.sum ./

# 下载依赖
RUN go mod download

# 复制源代码
COPY services/apps/ ./services/apps/

# 构建所有服务
RUN cd services/apps/basic-search && \
    go build -o /app/bin/basic-search ./cmd/server

RUN cd services/apps/service-a && \
    go build -o /app/bin/service-a ./cmd/server

FROM ubuntu:24.04
COPY --from=builder /app/bin /opt/services/
```

**优点：**
- ✅ 共享构建环境
- ✅ 减少重复代码
- ✅ 统一管理

**缺点：**
- ❌ 一个服务变更需要重新构建所有服务
- ❌ 镜像体积较大
- ❌ 不够灵活

---

### 方案三：Docker Compose 统一编排（推荐用于开发/测试）

**特点：**
- 使用 docker-compose 管理多个服务
- 适合本地开发和测试环境
- 可以统一管理服务依赖（数据库、Redis 等）

**目录结构：**
```
deploy/
├── docker-compose.yml
└── docker/
    ├── basic-search.Dockerfile
    ├── service-a.Dockerfile
    └── service-b.Dockerfile
```

**docker-compose.yml 示例：**
```yaml
version: '3.8'

services:
  basic-search:
    build:
      context: ..
      dockerfile: deploy/docker/basic-search.Dockerfile
    ports:
      - "8163:8163"
    environment:
      - CONFIG_PATH=/app/config/config.yaml
    volumes:
      - ../services/apps/basic-search/dev-config:/app/config
    depends_on:
      - opensearch
      - redis

  service-a:
    build:
      context: ..
      dockerfile: deploy/docker/service-a.Dockerfile
    ports:
      - "8164:8164"
    depends_on:
      - basic-search

  opensearch:
    image: opensearchproject/opensearch:latest
    ports:
      - "9200:9200"

  redis:
    image: redis:latest
    ports:
      - "6379:6379"
```

**优点：**
- ✅ 统一管理所有服务
- ✅ 方便本地开发
- ✅ 可以管理服务依赖
- ✅ 一键启动所有服务

**缺点：**
- ❌ 不适合生产环境
- ❌ 所有服务在同一机器上

---

### 方案四：Makefile 统一构建脚本

**特点：**
- 使用 Makefile 统一管理构建流程
- 支持批量构建和部署
- 灵活配置

**目录结构：**
```
deploy/
├── Makefile
└── scripts/
    ├── build-all.sh
    └── deploy-all.sh
```

**Makefile 示例：**
```makefile
SERVICES = basic-search service-a service-b
REGISTRY = your-registry.com
VERSION = $(shell git describe --tags --always)

.PHONY: build-all
build-all:
	@for service in $(SERVICES); do \
		echo "Building $$service..."; \
		cd services/apps/$$service && \
		docker build -f docker/Dockerfile -t $(REGISTRY)/$$service:$(VERSION) . && \
		cd ../../..; \
	done

.PHONY: push-all
push-all: build-all
	@for service in $(SERVICES); do \
		echo "Pushing $$service..."; \
		docker push $(REGISTRY)/$$service:$(VERSION); \
	done

.PHONY: deploy-all
deploy-all: push-all
	@echo "Deploying all services..."
	# 部署逻辑
```

**优点：**
- ✅ 灵活可控
- ✅ 支持批量操作
- ✅ 易于扩展

**缺点：**
- ❌ 需要维护脚本
- ❌ 需要手动管理

---

## 三、推荐方案

### 开发环境
**使用方案三（Docker Compose）**
- 方便本地开发
- 统一管理依赖服务
- 一键启动

### 生产环境
**使用方案一（独立 Docker 镜像）**
- 服务独立部署
- 支持独立扩展
- 符合微服务最佳实践

### CI/CD 流程
**使用方案四（Makefile 脚本）**
- 集成到 CI/CD 流程
- 批量构建和部署
- 版本管理统一

---

## 四、实施步骤

### 4.1 配置 go.work（可选）

如果需要在本地开发时共享代码，可以配置 go.work：

```bash
cd /Users/kingnet/code_workspace/go_workspace/src/kweaver-ai/dsg
go work init
go work use ./services/apps/basic-search
# 添加其他服务
go work use ./services/apps/service-a
```

### 4.2 创建统一部署目录

```bash
mkdir -p deploy/docker
mkdir -p deploy/scripts
```

### 4.3 选择并实施部署方案

根据实际需求选择上述方案之一进行实施。

---

## 五、注意事项

1. **go.work 不要提交到生产环境**
   - go.work 主要用于本地开发
   - CI/CD 应该使用各服务的 go.mod

2. **服务间依赖管理**
   - 如果服务间有依赖，考虑使用共享库（services/lib）
   - 或者通过 API 调用，而不是直接代码依赖

3. **版本管理**
   - 每个服务应该有独立的版本号
   - 使用 Git Tag 管理版本

4. **配置管理**
   - 每个服务应该有独立的配置文件
   - 使用环境变量或配置中心管理配置
