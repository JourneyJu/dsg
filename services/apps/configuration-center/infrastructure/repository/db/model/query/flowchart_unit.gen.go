// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/kweaver-ai/dsg/services/apps/configuration-center/infrastructure/repository/db/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newFlowchartUnit(db *gorm.DB, opts ...gen.DOOption) flowchartUnit {
	_flowchartUnit := flowchartUnit{}

	_flowchartUnit.flowchartUnitDo.UseDB(db, opts...)
	_flowchartUnit.flowchartUnitDo.UseModel(&model.FlowchartUnit{})

	tableName := _flowchartUnit.flowchartUnitDo.TableName()
	_flowchartUnit.ALL = field.NewAsterisk(tableName)
	_flowchartUnit.ID = field.NewString(tableName, "id")
	_flowchartUnit.UnitType = field.NewInt32(tableName, "unit_type")
	_flowchartUnit.UnitID = field.NewString(tableName, "unit_id")
	_flowchartUnit.Name = field.NewString(tableName, "name")
	_flowchartUnit.Description = field.NewString(tableName, "description")
	_flowchartUnit.ParentID = field.NewString(tableName, "parent_id")
	_flowchartUnit.ParentUnitID = field.NewString(tableName, "parent_unit_id")
	_flowchartUnit.SourceID = field.NewString(tableName, "source_id")
	_flowchartUnit.SourceUnitID = field.NewString(tableName, "source_unit_id")
	_flowchartUnit.TargetID = field.NewString(tableName, "target_id")
	_flowchartUnit.TargetUnitID = field.NewString(tableName, "target_unit_id")
	_flowchartUnit.UnitOrder = field.NewInt32(tableName, "unit_order")
	_flowchartUnit.FlowchartVersionID = field.NewString(tableName, "flowchart_version_id")
	_flowchartUnit.DeletedAt = field.NewField(tableName, "deleted_at")

	_flowchartUnit.fillFieldMap()

	return _flowchartUnit
}

type flowchartUnit struct {
	flowchartUnitDo flowchartUnitDo

	ALL                field.Asterisk
	ID                 field.String // 主键，uuid
	UnitType           field.Int32  // 单元类型，枚举：1：阶段；2：节点；3：连接线
	UnitID             field.String // 单元ID
	Name               field.String // 单元名称
	Description        field.String // 单元描述说明
	ParentID           field.String // 所属单元ID
	ParentUnitID       field.String // 所属单元ID，冗余
	SourceID           field.String // 来源单元ID
	SourceUnitID       field.String // 来源单元ID，冗余
	TargetID           field.String // 目标单元ID
	TargetUnitID       field.String // 目标单元ID，冗余
	UnitOrder          field.Int32  // 单元次序，目前主要为阶段的先后顺序，从1开始
	FlowchartVersionID field.String // 运营流程版本ID
	DeletedAt          field.Field  // 删除时间(逻辑删除)

	fieldMap map[string]field.Expr
}

func (f flowchartUnit) Table(newTableName string) *flowchartUnit {
	f.flowchartUnitDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f flowchartUnit) As(alias string) *flowchartUnit {
	f.flowchartUnitDo.DO = *(f.flowchartUnitDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *flowchartUnit) updateTableName(table string) *flowchartUnit {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewString(table, "id")
	f.UnitType = field.NewInt32(table, "unit_type")
	f.UnitID = field.NewString(table, "unit_id")
	f.Name = field.NewString(table, "name")
	f.Description = field.NewString(table, "description")
	f.ParentID = field.NewString(table, "parent_id")
	f.ParentUnitID = field.NewString(table, "parent_unit_id")
	f.SourceID = field.NewString(table, "source_id")
	f.SourceUnitID = field.NewString(table, "source_unit_id")
	f.TargetID = field.NewString(table, "target_id")
	f.TargetUnitID = field.NewString(table, "target_unit_id")
	f.UnitOrder = field.NewInt32(table, "unit_order")
	f.FlowchartVersionID = field.NewString(table, "flowchart_version_id")
	f.DeletedAt = field.NewField(table, "deleted_at")

	f.fillFieldMap()

	return f
}

func (f *flowchartUnit) WithContext(ctx context.Context) IFlowchartUnitDo {
	return f.flowchartUnitDo.WithContext(ctx)
}

func (f flowchartUnit) TableName() string { return f.flowchartUnitDo.TableName() }

func (f flowchartUnit) Alias() string { return f.flowchartUnitDo.Alias() }

func (f *flowchartUnit) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *flowchartUnit) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 14)
	f.fieldMap["id"] = f.ID
	f.fieldMap["unit_type"] = f.UnitType
	f.fieldMap["unit_id"] = f.UnitID
	f.fieldMap["name"] = f.Name
	f.fieldMap["description"] = f.Description
	f.fieldMap["parent_id"] = f.ParentID
	f.fieldMap["parent_unit_id"] = f.ParentUnitID
	f.fieldMap["source_id"] = f.SourceID
	f.fieldMap["source_unit_id"] = f.SourceUnitID
	f.fieldMap["target_id"] = f.TargetID
	f.fieldMap["target_unit_id"] = f.TargetUnitID
	f.fieldMap["unit_order"] = f.UnitOrder
	f.fieldMap["flowchart_version_id"] = f.FlowchartVersionID
	f.fieldMap["deleted_at"] = f.DeletedAt
}

func (f flowchartUnit) clone(db *gorm.DB) flowchartUnit {
	f.flowchartUnitDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f flowchartUnit) replaceDB(db *gorm.DB) flowchartUnit {
	f.flowchartUnitDo.ReplaceDB(db)
	return f
}

type flowchartUnitDo struct{ gen.DO }

type IFlowchartUnitDo interface {
	gen.SubQuery
	Debug() IFlowchartUnitDo
	WithContext(ctx context.Context) IFlowchartUnitDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFlowchartUnitDo
	WriteDB() IFlowchartUnitDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFlowchartUnitDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFlowchartUnitDo
	Not(conds ...gen.Condition) IFlowchartUnitDo
	Or(conds ...gen.Condition) IFlowchartUnitDo
	Select(conds ...field.Expr) IFlowchartUnitDo
	Where(conds ...gen.Condition) IFlowchartUnitDo
	Order(conds ...field.Expr) IFlowchartUnitDo
	Distinct(cols ...field.Expr) IFlowchartUnitDo
	Omit(cols ...field.Expr) IFlowchartUnitDo
	Join(table schema.Tabler, on ...field.Expr) IFlowchartUnitDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartUnitDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartUnitDo
	Group(cols ...field.Expr) IFlowchartUnitDo
	Having(conds ...gen.Condition) IFlowchartUnitDo
	Limit(limit int) IFlowchartUnitDo
	Offset(offset int) IFlowchartUnitDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartUnitDo
	Unscoped() IFlowchartUnitDo
	Create(values ...*model.FlowchartUnit) error
	CreateInBatches(values []*model.FlowchartUnit, batchSize int) error
	Save(values ...*model.FlowchartUnit) error
	First() (*model.FlowchartUnit, error)
	Take() (*model.FlowchartUnit, error)
	Last() (*model.FlowchartUnit, error)
	Find() ([]*model.FlowchartUnit, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FlowchartUnit, err error)
	FindInBatches(result *[]*model.FlowchartUnit, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FlowchartUnit) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFlowchartUnitDo
	Assign(attrs ...field.AssignExpr) IFlowchartUnitDo
	Joins(fields ...field.RelationField) IFlowchartUnitDo
	Preload(fields ...field.RelationField) IFlowchartUnitDo
	FirstOrInit() (*model.FlowchartUnit, error)
	FirstOrCreate() (*model.FlowchartUnit, error)
	FindByPage(offset int, limit int) (result []*model.FlowchartUnit, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFlowchartUnitDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f flowchartUnitDo) Debug() IFlowchartUnitDo {
	return f.withDO(f.DO.Debug())
}

func (f flowchartUnitDo) WithContext(ctx context.Context) IFlowchartUnitDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f flowchartUnitDo) ReadDB() IFlowchartUnitDo {
	return f.Clauses(dbresolver.Read)
}

func (f flowchartUnitDo) WriteDB() IFlowchartUnitDo {
	return f.Clauses(dbresolver.Write)
}

func (f flowchartUnitDo) Session(config *gorm.Session) IFlowchartUnitDo {
	return f.withDO(f.DO.Session(config))
}

func (f flowchartUnitDo) Clauses(conds ...clause.Expression) IFlowchartUnitDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f flowchartUnitDo) Returning(value interface{}, columns ...string) IFlowchartUnitDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f flowchartUnitDo) Not(conds ...gen.Condition) IFlowchartUnitDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f flowchartUnitDo) Or(conds ...gen.Condition) IFlowchartUnitDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f flowchartUnitDo) Select(conds ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f flowchartUnitDo) Where(conds ...gen.Condition) IFlowchartUnitDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f flowchartUnitDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IFlowchartUnitDo {
	return f.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (f flowchartUnitDo) Order(conds ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f flowchartUnitDo) Distinct(cols ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f flowchartUnitDo) Omit(cols ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f flowchartUnitDo) Join(table schema.Tabler, on ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f flowchartUnitDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f flowchartUnitDo) RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f flowchartUnitDo) Group(cols ...field.Expr) IFlowchartUnitDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f flowchartUnitDo) Having(conds ...gen.Condition) IFlowchartUnitDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f flowchartUnitDo) Limit(limit int) IFlowchartUnitDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f flowchartUnitDo) Offset(offset int) IFlowchartUnitDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f flowchartUnitDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartUnitDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f flowchartUnitDo) Unscoped() IFlowchartUnitDo {
	return f.withDO(f.DO.Unscoped())
}

func (f flowchartUnitDo) Create(values ...*model.FlowchartUnit) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f flowchartUnitDo) CreateInBatches(values []*model.FlowchartUnit, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f flowchartUnitDo) Save(values ...*model.FlowchartUnit) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f flowchartUnitDo) First() (*model.FlowchartUnit, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartUnit), nil
	}
}

func (f flowchartUnitDo) Take() (*model.FlowchartUnit, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartUnit), nil
	}
}

func (f flowchartUnitDo) Last() (*model.FlowchartUnit, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartUnit), nil
	}
}

func (f flowchartUnitDo) Find() ([]*model.FlowchartUnit, error) {
	result, err := f.DO.Find()
	return result.([]*model.FlowchartUnit), err
}

func (f flowchartUnitDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FlowchartUnit, err error) {
	buf := make([]*model.FlowchartUnit, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f flowchartUnitDo) FindInBatches(result *[]*model.FlowchartUnit, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f flowchartUnitDo) Attrs(attrs ...field.AssignExpr) IFlowchartUnitDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f flowchartUnitDo) Assign(attrs ...field.AssignExpr) IFlowchartUnitDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f flowchartUnitDo) Joins(fields ...field.RelationField) IFlowchartUnitDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f flowchartUnitDo) Preload(fields ...field.RelationField) IFlowchartUnitDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f flowchartUnitDo) FirstOrInit() (*model.FlowchartUnit, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartUnit), nil
	}
}

func (f flowchartUnitDo) FirstOrCreate() (*model.FlowchartUnit, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartUnit), nil
	}
}

func (f flowchartUnitDo) FindByPage(offset int, limit int) (result []*model.FlowchartUnit, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f flowchartUnitDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f flowchartUnitDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f flowchartUnitDo) Delete(models ...*model.FlowchartUnit) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *flowchartUnitDo) withDO(do gen.Dao) *flowchartUnitDo {
	f.DO = *do.(*gen.DO)
	return f
}
