// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/kweaver-ai/dsg/services/apps/configuration-center/infrastructure/repository/db/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newTDictItem(db *gorm.DB, opts ...gen.DOOption) tDictItem {
	_tDictItem := tDictItem{}

	_tDictItem.tDictItemDo.UseDB(db, opts...)
	_tDictItem.tDictItemDo.UseModel(&model.TDictItem{})

	tableName := _tDictItem.tDictItemDo.TableName()
	_tDictItem.ALL = field.NewAsterisk(tableName)
	_tDictItem.ID = field.NewInt64(tableName, "id")
	_tDictItem.DictID = field.NewInt64(tableName, "dict_id")
	_tDictItem.FType = field.NewString(tableName, "f_type")
	_tDictItem.FKey = field.NewString(tableName, "f_key")
	_tDictItem.FValue = field.NewString(tableName, "f_value")
	_tDictItem.FDescription = field.NewString(tableName, "f_description")
	_tDictItem.FSort = field.NewInt32(tableName, "f_sort")
	_tDictItem.CreatedAt = field.NewTime(tableName, "created_at")
	_tDictItem.CreatorUID = field.NewString(tableName, "creator_uid")
	_tDictItem.CreatorName = field.NewString(tableName, "creator_name")

	_tDictItem.fillFieldMap()

	return _tDictItem
}

type tDictItem struct {
	tDictItemDo tDictItemDo

	ALL          field.Asterisk
	ID           field.Int64  // 唯一id，雪花算法
	DictID       field.Int64  // 字典ID
	FType        field.String // 字典类型 area 所属领域、应用领域【应用系统】 scene 应用场景 scene-type 应用场景类型 one-thing 高效办成“一件事” range 应用范围 sensitive-level 敏感级别 catalog-share-type 数据目录共享类型 catalog-open-type 数据目录开放类型 resource-share-type 数据资源共享类型 resource-open-type 数据资源开放类型 resource-type 数据资源类型 column-type 字段类型 serve-type 服务类型 use-scope 使用范围 update-cycle 更新周期 publish 是否发布 share-type 共享类型 data-region 数据区域范围 level-type 数据所属层级 open-type 开放类型 certification-type 是否电子证照编码 net-type 提供渠道 data-processing 数据加工程度 data-backflow 是否回流地市（州） backflow-region 回流是否能区分地市（州） field-type 数据所属领域 org-code 统一社会信用代码 division-code 行政区划代码 center-dept-code 中央业务指导（实施）部门代码 data-sensitive-class 数据分级 catalog-tag 目录标签 system-class 系统所属分类
	FKey         field.String // 键（字典码）
	FValue       field.String // 值（值名称）
	FDescription field.String // 码值备注
	FSort        field.Int32  // 排序（升序）
	CreatedAt    field.Time   // 创建时间
	CreatorUID   field.String // 创建用户ID
	CreatorName  field.String // 创建用户名称

	fieldMap map[string]field.Expr
}

func (t tDictItem) Table(newTableName string) *tDictItem {
	t.tDictItemDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tDictItem) As(alias string) *tDictItem {
	t.tDictItemDo.DO = *(t.tDictItemDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tDictItem) updateTableName(table string) *tDictItem {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.DictID = field.NewInt64(table, "dict_id")
	t.FType = field.NewString(table, "f_type")
	t.FKey = field.NewString(table, "f_key")
	t.FValue = field.NewString(table, "f_value")
	t.FDescription = field.NewString(table, "f_description")
	t.FSort = field.NewInt32(table, "f_sort")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.CreatorUID = field.NewString(table, "creator_uid")
	t.CreatorName = field.NewString(table, "creator_name")

	t.fillFieldMap()

	return t
}

func (t *tDictItem) WithContext(ctx context.Context) ITDictItemDo {
	return t.tDictItemDo.WithContext(ctx)
}

func (t tDictItem) TableName() string { return t.tDictItemDo.TableName() }

func (t tDictItem) Alias() string { return t.tDictItemDo.Alias() }

func (t *tDictItem) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tDictItem) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 10)
	t.fieldMap["id"] = t.ID
	t.fieldMap["dict_id"] = t.DictID
	t.fieldMap["f_type"] = t.FType
	t.fieldMap["f_key"] = t.FKey
	t.fieldMap["f_value"] = t.FValue
	t.fieldMap["f_description"] = t.FDescription
	t.fieldMap["f_sort"] = t.FSort
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["creator_uid"] = t.CreatorUID
	t.fieldMap["creator_name"] = t.CreatorName
}

func (t tDictItem) clone(db *gorm.DB) tDictItem {
	t.tDictItemDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tDictItem) replaceDB(db *gorm.DB) tDictItem {
	t.tDictItemDo.ReplaceDB(db)
	return t
}

type tDictItemDo struct{ gen.DO }

type ITDictItemDo interface {
	gen.SubQuery
	Debug() ITDictItemDo
	WithContext(ctx context.Context) ITDictItemDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITDictItemDo
	WriteDB() ITDictItemDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITDictItemDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITDictItemDo
	Not(conds ...gen.Condition) ITDictItemDo
	Or(conds ...gen.Condition) ITDictItemDo
	Select(conds ...field.Expr) ITDictItemDo
	Where(conds ...gen.Condition) ITDictItemDo
	Order(conds ...field.Expr) ITDictItemDo
	Distinct(cols ...field.Expr) ITDictItemDo
	Omit(cols ...field.Expr) ITDictItemDo
	Join(table schema.Tabler, on ...field.Expr) ITDictItemDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITDictItemDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITDictItemDo
	Group(cols ...field.Expr) ITDictItemDo
	Having(conds ...gen.Condition) ITDictItemDo
	Limit(limit int) ITDictItemDo
	Offset(offset int) ITDictItemDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITDictItemDo
	Unscoped() ITDictItemDo
	Create(values ...*model.TDictItem) error
	CreateInBatches(values []*model.TDictItem, batchSize int) error
	Save(values ...*model.TDictItem) error
	First() (*model.TDictItem, error)
	Take() (*model.TDictItem, error)
	Last() (*model.TDictItem, error)
	Find() ([]*model.TDictItem, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TDictItem, err error)
	FindInBatches(result *[]*model.TDictItem, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TDictItem) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITDictItemDo
	Assign(attrs ...field.AssignExpr) ITDictItemDo
	Joins(fields ...field.RelationField) ITDictItemDo
	Preload(fields ...field.RelationField) ITDictItemDo
	FirstOrInit() (*model.TDictItem, error)
	FirstOrCreate() (*model.TDictItem, error)
	FindByPage(offset int, limit int) (result []*model.TDictItem, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITDictItemDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tDictItemDo) Debug() ITDictItemDo {
	return t.withDO(t.DO.Debug())
}

func (t tDictItemDo) WithContext(ctx context.Context) ITDictItemDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tDictItemDo) ReadDB() ITDictItemDo {
	return t.Clauses(dbresolver.Read)
}

func (t tDictItemDo) WriteDB() ITDictItemDo {
	return t.Clauses(dbresolver.Write)
}

func (t tDictItemDo) Session(config *gorm.Session) ITDictItemDo {
	return t.withDO(t.DO.Session(config))
}

func (t tDictItemDo) Clauses(conds ...clause.Expression) ITDictItemDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tDictItemDo) Returning(value interface{}, columns ...string) ITDictItemDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tDictItemDo) Not(conds ...gen.Condition) ITDictItemDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tDictItemDo) Or(conds ...gen.Condition) ITDictItemDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tDictItemDo) Select(conds ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tDictItemDo) Where(conds ...gen.Condition) ITDictItemDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tDictItemDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITDictItemDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tDictItemDo) Order(conds ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tDictItemDo) Distinct(cols ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tDictItemDo) Omit(cols ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tDictItemDo) Join(table schema.Tabler, on ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tDictItemDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tDictItemDo) RightJoin(table schema.Tabler, on ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tDictItemDo) Group(cols ...field.Expr) ITDictItemDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tDictItemDo) Having(conds ...gen.Condition) ITDictItemDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tDictItemDo) Limit(limit int) ITDictItemDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tDictItemDo) Offset(offset int) ITDictItemDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tDictItemDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITDictItemDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tDictItemDo) Unscoped() ITDictItemDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tDictItemDo) Create(values ...*model.TDictItem) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tDictItemDo) CreateInBatches(values []*model.TDictItem, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tDictItemDo) Save(values ...*model.TDictItem) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tDictItemDo) First() (*model.TDictItem, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TDictItem), nil
	}
}

func (t tDictItemDo) Take() (*model.TDictItem, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TDictItem), nil
	}
}

func (t tDictItemDo) Last() (*model.TDictItem, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TDictItem), nil
	}
}

func (t tDictItemDo) Find() ([]*model.TDictItem, error) {
	result, err := t.DO.Find()
	return result.([]*model.TDictItem), err
}

func (t tDictItemDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TDictItem, err error) {
	buf := make([]*model.TDictItem, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tDictItemDo) FindInBatches(result *[]*model.TDictItem, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tDictItemDo) Attrs(attrs ...field.AssignExpr) ITDictItemDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tDictItemDo) Assign(attrs ...field.AssignExpr) ITDictItemDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tDictItemDo) Joins(fields ...field.RelationField) ITDictItemDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tDictItemDo) Preload(fields ...field.RelationField) ITDictItemDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tDictItemDo) FirstOrInit() (*model.TDictItem, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TDictItem), nil
	}
}

func (t tDictItemDo) FirstOrCreate() (*model.TDictItem, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TDictItem), nil
	}
}

func (t tDictItemDo) FindByPage(offset int, limit int) (result []*model.TDictItem, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tDictItemDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tDictItemDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tDictItemDo) Delete(models ...*model.TDictItem) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tDictItemDo) withDO(do gen.Dao) *tDictItemDo {
	t.DO = *do.(*gen.DO)
	return t
}
