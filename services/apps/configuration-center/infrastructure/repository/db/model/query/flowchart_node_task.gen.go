// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/kweaver-ai/dsg/services/apps/configuration-center/infrastructure/repository/db/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newFlowchartNodeTask(db *gorm.DB, opts ...gen.DOOption) flowchartNodeTask {
	_flowchartNodeTask := flowchartNodeTask{}

	_flowchartNodeTask.flowchartNodeTaskDo.UseDB(db, opts...)
	_flowchartNodeTask.flowchartNodeTaskDo.UseModel(&model.FlowchartNodeTask{})

	tableName := _flowchartNodeTask.flowchartNodeTaskDo.TableName()
	_flowchartNodeTask.ALL = field.NewAsterisk(tableName)
	_flowchartNodeTask.ID = field.NewString(tableName, "id")
	_flowchartNodeTask.Name = field.NewString(tableName, "name")
	_flowchartNodeTask.CompletionMode = field.NewInt32(tableName, "completion_mode")
	//_flowchartNodeTask.ExecRoleID = field.NewString(tableName, "exec_role_id")
	_flowchartNodeTask.NodeID = field.NewString(tableName, "node_id")
	_flowchartNodeTask.NodeUnitID = field.NewString(tableName, "node_unit_id")
	_flowchartNodeTask.FlowchartVersionID = field.NewString(tableName, "flowchart_version_id")
	_flowchartNodeTask.TaskType = field.NewInt32(tableName, "task_type")
	_flowchartNodeTask.DeletedAt = field.NewField(tableName, "deleted_at")

	_flowchartNodeTask.fillFieldMap()

	return _flowchartNodeTask
}

type flowchartNodeTask struct {
	flowchartNodeTaskDo flowchartNodeTaskDo

	ALL            field.Asterisk
	ID             field.String // 主键，uuid
	Name           field.String // 任务类型名称
	CompletionMode field.Int32  // 完成方式，枚举：1：手动确认；2：自动完成
	//ExecRoleID         field.String // 执行角色
	NodeID             field.String // 节点ID，flowchart_unit表的id字段
	NodeUnitID         field.String // 节点组件ID，冗余
	FlowchartVersionID field.String // 运营流程版本ID
	TaskType           field.Int32  // 任务类型数组，取值范围:1 普通任务(默认)，2 新建模型类任务，4 标准化任务。
	DeletedAt          field.Field  // 删除时间(逻辑删除)

	fieldMap map[string]field.Expr
}

func (f flowchartNodeTask) Table(newTableName string) *flowchartNodeTask {
	f.flowchartNodeTaskDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f flowchartNodeTask) As(alias string) *flowchartNodeTask {
	f.flowchartNodeTaskDo.DO = *(f.flowchartNodeTaskDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *flowchartNodeTask) updateTableName(table string) *flowchartNodeTask {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewString(table, "id")
	f.Name = field.NewString(table, "name")
	f.CompletionMode = field.NewInt32(table, "completion_mode")
	//f.ExecRoleID = field.NewString(table, "exec_role_id")
	f.NodeID = field.NewString(table, "node_id")
	f.NodeUnitID = field.NewString(table, "node_unit_id")
	f.FlowchartVersionID = field.NewString(table, "flowchart_version_id")
	f.TaskType = field.NewInt32(table, "task_type")
	f.DeletedAt = field.NewField(table, "deleted_at")

	f.fillFieldMap()

	return f
}

func (f *flowchartNodeTask) WithContext(ctx context.Context) IFlowchartNodeTaskDo {
	return f.flowchartNodeTaskDo.WithContext(ctx)
}

func (f flowchartNodeTask) TableName() string { return f.flowchartNodeTaskDo.TableName() }

func (f flowchartNodeTask) Alias() string { return f.flowchartNodeTaskDo.Alias() }

func (f *flowchartNodeTask) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *flowchartNodeTask) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 9)
	f.fieldMap["id"] = f.ID
	f.fieldMap["name"] = f.Name
	f.fieldMap["completion_mode"] = f.CompletionMode
	//f.fieldMap["exec_role_id"] = f.ExecRoleID
	f.fieldMap["node_id"] = f.NodeID
	f.fieldMap["node_unit_id"] = f.NodeUnitID
	f.fieldMap["flowchart_version_id"] = f.FlowchartVersionID
	f.fieldMap["task_type"] = f.TaskType
	f.fieldMap["deleted_at"] = f.DeletedAt
}

func (f flowchartNodeTask) clone(db *gorm.DB) flowchartNodeTask {
	f.flowchartNodeTaskDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f flowchartNodeTask) replaceDB(db *gorm.DB) flowchartNodeTask {
	f.flowchartNodeTaskDo.ReplaceDB(db)
	return f
}

type flowchartNodeTaskDo struct{ gen.DO }

type IFlowchartNodeTaskDo interface {
	gen.SubQuery
	Debug() IFlowchartNodeTaskDo
	WithContext(ctx context.Context) IFlowchartNodeTaskDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFlowchartNodeTaskDo
	WriteDB() IFlowchartNodeTaskDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFlowchartNodeTaskDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFlowchartNodeTaskDo
	Not(conds ...gen.Condition) IFlowchartNodeTaskDo
	Or(conds ...gen.Condition) IFlowchartNodeTaskDo
	Select(conds ...field.Expr) IFlowchartNodeTaskDo
	Where(conds ...gen.Condition) IFlowchartNodeTaskDo
	Order(conds ...field.Expr) IFlowchartNodeTaskDo
	Distinct(cols ...field.Expr) IFlowchartNodeTaskDo
	Omit(cols ...field.Expr) IFlowchartNodeTaskDo
	Join(table schema.Tabler, on ...field.Expr) IFlowchartNodeTaskDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeTaskDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeTaskDo
	Group(cols ...field.Expr) IFlowchartNodeTaskDo
	Having(conds ...gen.Condition) IFlowchartNodeTaskDo
	Limit(limit int) IFlowchartNodeTaskDo
	Offset(offset int) IFlowchartNodeTaskDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartNodeTaskDo
	Unscoped() IFlowchartNodeTaskDo
	Create(values ...*model.FlowchartNodeTask) error
	CreateInBatches(values []*model.FlowchartNodeTask, batchSize int) error
	Save(values ...*model.FlowchartNodeTask) error
	First() (*model.FlowchartNodeTask, error)
	Take() (*model.FlowchartNodeTask, error)
	Last() (*model.FlowchartNodeTask, error)
	Find() ([]*model.FlowchartNodeTask, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FlowchartNodeTask, err error)
	FindInBatches(result *[]*model.FlowchartNodeTask, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FlowchartNodeTask) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFlowchartNodeTaskDo
	Assign(attrs ...field.AssignExpr) IFlowchartNodeTaskDo
	Joins(fields ...field.RelationField) IFlowchartNodeTaskDo
	Preload(fields ...field.RelationField) IFlowchartNodeTaskDo
	FirstOrInit() (*model.FlowchartNodeTask, error)
	FirstOrCreate() (*model.FlowchartNodeTask, error)
	FindByPage(offset int, limit int) (result []*model.FlowchartNodeTask, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFlowchartNodeTaskDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f flowchartNodeTaskDo) Debug() IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Debug())
}

func (f flowchartNodeTaskDo) WithContext(ctx context.Context) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f flowchartNodeTaskDo) ReadDB() IFlowchartNodeTaskDo {
	return f.Clauses(dbresolver.Read)
}

func (f flowchartNodeTaskDo) WriteDB() IFlowchartNodeTaskDo {
	return f.Clauses(dbresolver.Write)
}

func (f flowchartNodeTaskDo) Session(config *gorm.Session) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Session(config))
}

func (f flowchartNodeTaskDo) Clauses(conds ...clause.Expression) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f flowchartNodeTaskDo) Returning(value interface{}, columns ...string) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f flowchartNodeTaskDo) Not(conds ...gen.Condition) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f flowchartNodeTaskDo) Or(conds ...gen.Condition) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f flowchartNodeTaskDo) Select(conds ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f flowchartNodeTaskDo) Where(conds ...gen.Condition) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f flowchartNodeTaskDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IFlowchartNodeTaskDo {
	return f.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (f flowchartNodeTaskDo) Order(conds ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f flowchartNodeTaskDo) Distinct(cols ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f flowchartNodeTaskDo) Omit(cols ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f flowchartNodeTaskDo) Join(table schema.Tabler, on ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f flowchartNodeTaskDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f flowchartNodeTaskDo) RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f flowchartNodeTaskDo) Group(cols ...field.Expr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f flowchartNodeTaskDo) Having(conds ...gen.Condition) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f flowchartNodeTaskDo) Limit(limit int) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f flowchartNodeTaskDo) Offset(offset int) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f flowchartNodeTaskDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f flowchartNodeTaskDo) Unscoped() IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Unscoped())
}

func (f flowchartNodeTaskDo) Create(values ...*model.FlowchartNodeTask) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f flowchartNodeTaskDo) CreateInBatches(values []*model.FlowchartNodeTask, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f flowchartNodeTaskDo) Save(values ...*model.FlowchartNodeTask) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f flowchartNodeTaskDo) First() (*model.FlowchartNodeTask, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeTask), nil
	}
}

func (f flowchartNodeTaskDo) Take() (*model.FlowchartNodeTask, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeTask), nil
	}
}

func (f flowchartNodeTaskDo) Last() (*model.FlowchartNodeTask, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeTask), nil
	}
}

func (f flowchartNodeTaskDo) Find() ([]*model.FlowchartNodeTask, error) {
	result, err := f.DO.Find()
	return result.([]*model.FlowchartNodeTask), err
}

func (f flowchartNodeTaskDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FlowchartNodeTask, err error) {
	buf := make([]*model.FlowchartNodeTask, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f flowchartNodeTaskDo) FindInBatches(result *[]*model.FlowchartNodeTask, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f flowchartNodeTaskDo) Attrs(attrs ...field.AssignExpr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f flowchartNodeTaskDo) Assign(attrs ...field.AssignExpr) IFlowchartNodeTaskDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f flowchartNodeTaskDo) Joins(fields ...field.RelationField) IFlowchartNodeTaskDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f flowchartNodeTaskDo) Preload(fields ...field.RelationField) IFlowchartNodeTaskDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f flowchartNodeTaskDo) FirstOrInit() (*model.FlowchartNodeTask, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeTask), nil
	}
}

func (f flowchartNodeTaskDo) FirstOrCreate() (*model.FlowchartNodeTask, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeTask), nil
	}
}

func (f flowchartNodeTaskDo) FindByPage(offset int, limit int) (result []*model.FlowchartNodeTask, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f flowchartNodeTaskDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f flowchartNodeTaskDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f flowchartNodeTaskDo) Delete(models ...*model.FlowchartNodeTask) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *flowchartNodeTaskDo) withDO(do gen.Dao) *flowchartNodeTaskDo {
	f.DO = *do.(*gen.DO)
	return f
}
