// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/kweaver-ai/dsg/services/apps/configuration-center/infrastructure/repository/db/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newFlowchartNodeConfig(db *gorm.DB, opts ...gen.DOOption) flowchartNodeConfig {
	_flowchartNodeConfig := flowchartNodeConfig{}

	_flowchartNodeConfig.flowchartNodeConfigDo.UseDB(db, opts...)
	_flowchartNodeConfig.flowchartNodeConfigDo.UseModel(&model.FlowchartNodeConfig{})

	tableName := _flowchartNodeConfig.flowchartNodeConfigDo.TableName()
	_flowchartNodeConfig.ALL = field.NewAsterisk(tableName)
	_flowchartNodeConfig.ID = field.NewString(tableName, "id")
	_flowchartNodeConfig.StartMode = field.NewInt32(tableName, "start_mode")
	_flowchartNodeConfig.CompletionMode = field.NewInt32(tableName, "completion_mode")
	_flowchartNodeConfig.NodeID = field.NewString(tableName, "node_id")
	_flowchartNodeConfig.FlowchartVersionID = field.NewString(tableName, "flowchart_version_id")
	_flowchartNodeConfig.DeletedAt = field.NewField(tableName, "deleted_at")

	_flowchartNodeConfig.fillFieldMap()

	return _flowchartNodeConfig
}

type flowchartNodeConfig struct {
	flowchartNodeConfigDo flowchartNodeConfigDo

	ALL                field.Asterisk
	ID                 field.String // 主键，uuid
	StartMode          field.Int32  // 启动方式，枚举：1：任一前序节点完成；2：全部前序节点完成；3：任一前序节点处于非未启动
	CompletionMode     field.Int32  // 完成方式，枚举：1：手动确认；2：自动完成
	NodeID             field.String // 节点ID，flowchart_unit表的id字段
	FlowchartVersionID field.String // 运营流程版本ID
	DeletedAt          field.Field  // 删除时间(逻辑删除)

	fieldMap map[string]field.Expr
}

func (f flowchartNodeConfig) Table(newTableName string) *flowchartNodeConfig {
	f.flowchartNodeConfigDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f flowchartNodeConfig) As(alias string) *flowchartNodeConfig {
	f.flowchartNodeConfigDo.DO = *(f.flowchartNodeConfigDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *flowchartNodeConfig) updateTableName(table string) *flowchartNodeConfig {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewString(table, "id")
	f.StartMode = field.NewInt32(table, "start_mode")
	f.CompletionMode = field.NewInt32(table, "completion_mode")
	f.NodeID = field.NewString(table, "node_id")
	f.FlowchartVersionID = field.NewString(table, "flowchart_version_id")
	f.DeletedAt = field.NewField(table, "deleted_at")

	f.fillFieldMap()

	return f
}

func (f *flowchartNodeConfig) WithContext(ctx context.Context) IFlowchartNodeConfigDo {
	return f.flowchartNodeConfigDo.WithContext(ctx)
}

func (f flowchartNodeConfig) TableName() string { return f.flowchartNodeConfigDo.TableName() }

func (f flowchartNodeConfig) Alias() string { return f.flowchartNodeConfigDo.Alias() }

func (f *flowchartNodeConfig) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *flowchartNodeConfig) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 6)
	f.fieldMap["id"] = f.ID
	f.fieldMap["start_mode"] = f.StartMode
	f.fieldMap["completion_mode"] = f.CompletionMode
	f.fieldMap["node_id"] = f.NodeID
	f.fieldMap["flowchart_version_id"] = f.FlowchartVersionID
	f.fieldMap["deleted_at"] = f.DeletedAt
}

func (f flowchartNodeConfig) clone(db *gorm.DB) flowchartNodeConfig {
	f.flowchartNodeConfigDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f flowchartNodeConfig) replaceDB(db *gorm.DB) flowchartNodeConfig {
	f.flowchartNodeConfigDo.ReplaceDB(db)
	return f
}

type flowchartNodeConfigDo struct{ gen.DO }

type IFlowchartNodeConfigDo interface {
	gen.SubQuery
	Debug() IFlowchartNodeConfigDo
	WithContext(ctx context.Context) IFlowchartNodeConfigDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFlowchartNodeConfigDo
	WriteDB() IFlowchartNodeConfigDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFlowchartNodeConfigDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFlowchartNodeConfigDo
	Not(conds ...gen.Condition) IFlowchartNodeConfigDo
	Or(conds ...gen.Condition) IFlowchartNodeConfigDo
	Select(conds ...field.Expr) IFlowchartNodeConfigDo
	Where(conds ...gen.Condition) IFlowchartNodeConfigDo
	Order(conds ...field.Expr) IFlowchartNodeConfigDo
	Distinct(cols ...field.Expr) IFlowchartNodeConfigDo
	Omit(cols ...field.Expr) IFlowchartNodeConfigDo
	Join(table schema.Tabler, on ...field.Expr) IFlowchartNodeConfigDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeConfigDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeConfigDo
	Group(cols ...field.Expr) IFlowchartNodeConfigDo
	Having(conds ...gen.Condition) IFlowchartNodeConfigDo
	Limit(limit int) IFlowchartNodeConfigDo
	Offset(offset int) IFlowchartNodeConfigDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartNodeConfigDo
	Unscoped() IFlowchartNodeConfigDo
	Create(values ...*model.FlowchartNodeConfig) error
	CreateInBatches(values []*model.FlowchartNodeConfig, batchSize int) error
	Save(values ...*model.FlowchartNodeConfig) error
	First() (*model.FlowchartNodeConfig, error)
	Take() (*model.FlowchartNodeConfig, error)
	Last() (*model.FlowchartNodeConfig, error)
	Find() ([]*model.FlowchartNodeConfig, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FlowchartNodeConfig, err error)
	FindInBatches(result *[]*model.FlowchartNodeConfig, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FlowchartNodeConfig) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFlowchartNodeConfigDo
	Assign(attrs ...field.AssignExpr) IFlowchartNodeConfigDo
	Joins(fields ...field.RelationField) IFlowchartNodeConfigDo
	Preload(fields ...field.RelationField) IFlowchartNodeConfigDo
	FirstOrInit() (*model.FlowchartNodeConfig, error)
	FirstOrCreate() (*model.FlowchartNodeConfig, error)
	FindByPage(offset int, limit int) (result []*model.FlowchartNodeConfig, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFlowchartNodeConfigDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f flowchartNodeConfigDo) Debug() IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Debug())
}

func (f flowchartNodeConfigDo) WithContext(ctx context.Context) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f flowchartNodeConfigDo) ReadDB() IFlowchartNodeConfigDo {
	return f.Clauses(dbresolver.Read)
}

func (f flowchartNodeConfigDo) WriteDB() IFlowchartNodeConfigDo {
	return f.Clauses(dbresolver.Write)
}

func (f flowchartNodeConfigDo) Session(config *gorm.Session) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Session(config))
}

func (f flowchartNodeConfigDo) Clauses(conds ...clause.Expression) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f flowchartNodeConfigDo) Returning(value interface{}, columns ...string) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f flowchartNodeConfigDo) Not(conds ...gen.Condition) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f flowchartNodeConfigDo) Or(conds ...gen.Condition) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f flowchartNodeConfigDo) Select(conds ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f flowchartNodeConfigDo) Where(conds ...gen.Condition) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f flowchartNodeConfigDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IFlowchartNodeConfigDo {
	return f.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (f flowchartNodeConfigDo) Order(conds ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f flowchartNodeConfigDo) Distinct(cols ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f flowchartNodeConfigDo) Omit(cols ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f flowchartNodeConfigDo) Join(table schema.Tabler, on ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f flowchartNodeConfigDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f flowchartNodeConfigDo) RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f flowchartNodeConfigDo) Group(cols ...field.Expr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f flowchartNodeConfigDo) Having(conds ...gen.Condition) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f flowchartNodeConfigDo) Limit(limit int) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f flowchartNodeConfigDo) Offset(offset int) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f flowchartNodeConfigDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f flowchartNodeConfigDo) Unscoped() IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Unscoped())
}

func (f flowchartNodeConfigDo) Create(values ...*model.FlowchartNodeConfig) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f flowchartNodeConfigDo) CreateInBatches(values []*model.FlowchartNodeConfig, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f flowchartNodeConfigDo) Save(values ...*model.FlowchartNodeConfig) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f flowchartNodeConfigDo) First() (*model.FlowchartNodeConfig, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeConfig), nil
	}
}

func (f flowchartNodeConfigDo) Take() (*model.FlowchartNodeConfig, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeConfig), nil
	}
}

func (f flowchartNodeConfigDo) Last() (*model.FlowchartNodeConfig, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeConfig), nil
	}
}

func (f flowchartNodeConfigDo) Find() ([]*model.FlowchartNodeConfig, error) {
	result, err := f.DO.Find()
	return result.([]*model.FlowchartNodeConfig), err
}

func (f flowchartNodeConfigDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FlowchartNodeConfig, err error) {
	buf := make([]*model.FlowchartNodeConfig, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f flowchartNodeConfigDo) FindInBatches(result *[]*model.FlowchartNodeConfig, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f flowchartNodeConfigDo) Attrs(attrs ...field.AssignExpr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f flowchartNodeConfigDo) Assign(attrs ...field.AssignExpr) IFlowchartNodeConfigDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f flowchartNodeConfigDo) Joins(fields ...field.RelationField) IFlowchartNodeConfigDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f flowchartNodeConfigDo) Preload(fields ...field.RelationField) IFlowchartNodeConfigDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f flowchartNodeConfigDo) FirstOrInit() (*model.FlowchartNodeConfig, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeConfig), nil
	}
}

func (f flowchartNodeConfigDo) FirstOrCreate() (*model.FlowchartNodeConfig, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FlowchartNodeConfig), nil
	}
}

func (f flowchartNodeConfigDo) FindByPage(offset int, limit int) (result []*model.FlowchartNodeConfig, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f flowchartNodeConfigDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f flowchartNodeConfigDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f flowchartNodeConfigDo) Delete(models ...*model.FlowchartNodeConfig) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *flowchartNodeConfigDo) withDO(do gen.Dao) *flowchartNodeConfigDo {
	f.DO = *do.(*gen.DO)
	return f
}
