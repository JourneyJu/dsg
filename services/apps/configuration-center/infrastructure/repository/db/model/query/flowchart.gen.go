// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/kweaver-ai/dsg/services/apps/configuration-center/infrastructure/repository/db/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newFlowchart(db *gorm.DB, opts ...gen.DOOption) flowchart {
	_flowchart := flowchart{}

	_flowchart.flowchartDo.UseDB(db, opts...)
	_flowchart.flowchartDo.UseModel(&model.Flowchart{})

	tableName := _flowchart.flowchartDo.TableName()
	_flowchart.ALL = field.NewAsterisk(tableName)
	_flowchart.ID = field.NewString(tableName, "id")
	_flowchart.Name = field.NewString(tableName, "name")
	_flowchart.Description = field.NewString(tableName, "description")
	_flowchart.EditStatus = field.NewInt32(tableName, "edit_status")
	//_flowchart.ConfigStatus = field.NewInt32(tableName, "config_status")
	_flowchart.CurrentVersionID = field.NewString(tableName, "current_version_id")
	_flowchart.EditingVersionID = field.NewString(tableName, "editing_version_id")
	_flowchart.ClonedByID = field.NewString(tableName, "cloned_by_id")
	_flowchart.ClonedByTemplateID = field.NewString(tableName, "cloned_by_template_id")
	_flowchart.CreatedAt = field.NewTime(tableName, "created_at")
	_flowchart.CreatedByUID = field.NewString(tableName, "created_by_uid")
	_flowchart.UpdatedAt = field.NewTime(tableName, "updated_at")
	_flowchart.UpdatedByUID = field.NewString(tableName, "updated_by_uid")
	_flowchart.DeletedAt = field.NewField(tableName, "deleted_at")

	_flowchart.fillFieldMap()

	return _flowchart
}

type flowchart struct {
	flowchartDo flowchartDo

	ALL         field.Asterisk
	ID          field.String // 主键，uuid
	Name        field.String // 运营流程名称
	Description field.String // 运营流程描述说明
	EditStatus  field.Int32  // 当前版本运营流程编辑状态，枚举：1：新建中；2：正常；3：编辑中
	//ConfigStatus       field.Int32  // 运营流程配置状态，默认1正常，2任务执行角色缺失
	CurrentVersionID   field.String // 当前使用的已发布运营流程版本ID
	EditingVersionID   field.String // 正在编辑的运营流程版本ID
	ClonedByID         field.String // 复用的运营流程ID，空表示没有复用
	ClonedByTemplateID field.String // 复用的运营流程模版ID，空表示没有复用
	CreatedAt          field.Time   // 创建时间
	CreatedByUID       field.String // 创建用户ID
	UpdatedAt          field.Time   // 更新时间
	UpdatedByUID       field.String // 更新用户ID
	DeletedAt          field.Field  // 删除时间(逻辑删除)

	fieldMap map[string]field.Expr
}

func (f flowchart) Table(newTableName string) *flowchart {
	f.flowchartDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f flowchart) As(alias string) *flowchart {
	f.flowchartDo.DO = *(f.flowchartDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *flowchart) updateTableName(table string) *flowchart {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewString(table, "id")
	f.Name = field.NewString(table, "name")
	f.Description = field.NewString(table, "description")
	f.EditStatus = field.NewInt32(table, "edit_status")
	//f.ConfigStatus = field.NewInt32(table, "config_status")
	f.CurrentVersionID = field.NewString(table, "current_version_id")
	f.EditingVersionID = field.NewString(table, "editing_version_id")
	f.ClonedByID = field.NewString(table, "cloned_by_id")
	f.ClonedByTemplateID = field.NewString(table, "cloned_by_template_id")
	f.CreatedAt = field.NewTime(table, "created_at")
	f.CreatedByUID = field.NewString(table, "created_by_uid")
	f.UpdatedAt = field.NewTime(table, "updated_at")
	f.UpdatedByUID = field.NewString(table, "updated_by_uid")
	f.DeletedAt = field.NewField(table, "deleted_at")

	f.fillFieldMap()

	return f
}

func (f *flowchart) WithContext(ctx context.Context) IFlowchartDo {
	return f.flowchartDo.WithContext(ctx)
}

func (f flowchart) TableName() string { return f.flowchartDo.TableName() }

func (f flowchart) Alias() string { return f.flowchartDo.Alias() }

func (f *flowchart) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *flowchart) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 14)
	f.fieldMap["id"] = f.ID
	f.fieldMap["name"] = f.Name
	f.fieldMap["description"] = f.Description
	f.fieldMap["edit_status"] = f.EditStatus
	//f.fieldMap["config_status"] = f.ConfigStatus
	f.fieldMap["current_version_id"] = f.CurrentVersionID
	f.fieldMap["editing_version_id"] = f.EditingVersionID
	f.fieldMap["cloned_by_id"] = f.ClonedByID
	f.fieldMap["cloned_by_template_id"] = f.ClonedByTemplateID
	f.fieldMap["created_at"] = f.CreatedAt
	f.fieldMap["created_by_uid"] = f.CreatedByUID
	f.fieldMap["updated_at"] = f.UpdatedAt
	f.fieldMap["updated_by_uid"] = f.UpdatedByUID
	f.fieldMap["deleted_at"] = f.DeletedAt
}

func (f flowchart) clone(db *gorm.DB) flowchart {
	f.flowchartDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f flowchart) replaceDB(db *gorm.DB) flowchart {
	f.flowchartDo.ReplaceDB(db)
	return f
}

type flowchartDo struct{ gen.DO }

type IFlowchartDo interface {
	gen.SubQuery
	Debug() IFlowchartDo
	WithContext(ctx context.Context) IFlowchartDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFlowchartDo
	WriteDB() IFlowchartDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFlowchartDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFlowchartDo
	Not(conds ...gen.Condition) IFlowchartDo
	Or(conds ...gen.Condition) IFlowchartDo
	Select(conds ...field.Expr) IFlowchartDo
	Where(conds ...gen.Condition) IFlowchartDo
	Order(conds ...field.Expr) IFlowchartDo
	Distinct(cols ...field.Expr) IFlowchartDo
	Omit(cols ...field.Expr) IFlowchartDo
	Join(table schema.Tabler, on ...field.Expr) IFlowchartDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartDo
	Group(cols ...field.Expr) IFlowchartDo
	Having(conds ...gen.Condition) IFlowchartDo
	Limit(limit int) IFlowchartDo
	Offset(offset int) IFlowchartDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartDo
	Unscoped() IFlowchartDo
	Create(values ...*model.Flowchart) error
	CreateInBatches(values []*model.Flowchart, batchSize int) error
	Save(values ...*model.Flowchart) error
	First() (*model.Flowchart, error)
	Take() (*model.Flowchart, error)
	Last() (*model.Flowchart, error)
	Find() ([]*model.Flowchart, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Flowchart, err error)
	FindInBatches(result *[]*model.Flowchart, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Flowchart) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFlowchartDo
	Assign(attrs ...field.AssignExpr) IFlowchartDo
	Joins(fields ...field.RelationField) IFlowchartDo
	Preload(fields ...field.RelationField) IFlowchartDo
	FirstOrInit() (*model.Flowchart, error)
	FirstOrCreate() (*model.Flowchart, error)
	FindByPage(offset int, limit int) (result []*model.Flowchart, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFlowchartDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f flowchartDo) Debug() IFlowchartDo {
	return f.withDO(f.DO.Debug())
}

func (f flowchartDo) WithContext(ctx context.Context) IFlowchartDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f flowchartDo) ReadDB() IFlowchartDo {
	return f.Clauses(dbresolver.Read)
}

func (f flowchartDo) WriteDB() IFlowchartDo {
	return f.Clauses(dbresolver.Write)
}

func (f flowchartDo) Session(config *gorm.Session) IFlowchartDo {
	return f.withDO(f.DO.Session(config))
}

func (f flowchartDo) Clauses(conds ...clause.Expression) IFlowchartDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f flowchartDo) Returning(value interface{}, columns ...string) IFlowchartDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f flowchartDo) Not(conds ...gen.Condition) IFlowchartDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f flowchartDo) Or(conds ...gen.Condition) IFlowchartDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f flowchartDo) Select(conds ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f flowchartDo) Where(conds ...gen.Condition) IFlowchartDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f flowchartDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IFlowchartDo {
	return f.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (f flowchartDo) Order(conds ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f flowchartDo) Distinct(cols ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f flowchartDo) Omit(cols ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f flowchartDo) Join(table schema.Tabler, on ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f flowchartDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f flowchartDo) RightJoin(table schema.Tabler, on ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f flowchartDo) Group(cols ...field.Expr) IFlowchartDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f flowchartDo) Having(conds ...gen.Condition) IFlowchartDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f flowchartDo) Limit(limit int) IFlowchartDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f flowchartDo) Offset(offset int) IFlowchartDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f flowchartDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFlowchartDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f flowchartDo) Unscoped() IFlowchartDo {
	return f.withDO(f.DO.Unscoped())
}

func (f flowchartDo) Create(values ...*model.Flowchart) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f flowchartDo) CreateInBatches(values []*model.Flowchart, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f flowchartDo) Save(values ...*model.Flowchart) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f flowchartDo) First() (*model.Flowchart, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Flowchart), nil
	}
}

func (f flowchartDo) Take() (*model.Flowchart, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Flowchart), nil
	}
}

func (f flowchartDo) Last() (*model.Flowchart, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Flowchart), nil
	}
}

func (f flowchartDo) Find() ([]*model.Flowchart, error) {
	result, err := f.DO.Find()
	return result.([]*model.Flowchart), err
}

func (f flowchartDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Flowchart, err error) {
	buf := make([]*model.Flowchart, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f flowchartDo) FindInBatches(result *[]*model.Flowchart, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f flowchartDo) Attrs(attrs ...field.AssignExpr) IFlowchartDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f flowchartDo) Assign(attrs ...field.AssignExpr) IFlowchartDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f flowchartDo) Joins(fields ...field.RelationField) IFlowchartDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f flowchartDo) Preload(fields ...field.RelationField) IFlowchartDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f flowchartDo) FirstOrInit() (*model.Flowchart, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Flowchart), nil
	}
}

func (f flowchartDo) FirstOrCreate() (*model.Flowchart, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Flowchart), nil
	}
}

func (f flowchartDo) FindByPage(offset int, limit int) (result []*model.Flowchart, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f flowchartDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f flowchartDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f flowchartDo) Delete(models ...*model.Flowchart) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *flowchartDo) withDO(do gen.Dao) *flowchartDo {
	f.DO = *do.(*gen.DO)
	return f
}
